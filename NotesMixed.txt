

----MicroService
--how much small service we can create. there must be some pattern
--differnt phase of microservice
1. decompostion
2. database 
3. communciation
4. integration
5. ... and gooes



decompostion patterbs 
if we monolthinc application we can diuvide 
1. decomposbe by bussines capalibility or functionality
2. decompse by sub domomain(ddd)-domain driven design ->
just we have shopping application
order deomain and their have mutliple microservceis
order domain --their microserrvices




2. database  : single databse or all have same database
-ddatbase per service or database share service for all

3. communciation:
--via api
- via events

4. integraee:
-- tghis is increate with otehr app or api gateway

5. 

---pattern
Strangler pattern :
REFCATOR THE MICROSERVCEI FROM MONLOTHIC SERVICE
SLOWLY SLOWLY CONVERTING MONOLTHIC APLTAION TO MICROSERVCEI

saga  :


CQRS :

-----------------------------

** DATA MANAGMENT IN MicroService
1. Database  for each service invidual (SAGA ,CQRS)

**benefit:
all servcie can u use different database provide like ,sql, cosmos db, as per their requiremnt
**issues :
 tranaction issues -> solved by SAGA
 if need data from mutiple tables  means some table in database1  and  some table in database2  -> solve  by cqrs(helping in join )

-----benefit
-- easy to scale induvidual database

2. Database for common for all sevice shared database -NOT MUCHS SUCCESSFULL
->benefit : ACID (Transaction is mentioned easily)
 Drawback : 
 1. IF ISSUES IN ONE tbale THEN need to DEPLOY ALL TABLES
 2.Need to scale table that is no needed ie either all or none

*SAGA
--SEQUENCE OF LOCAL TRANSACTION
--FAILURE EVENT SEND BACK IF ANY STEP FAILED SOME THING
-Saga is of two types or we can say saga can implemented by two approach

1 Chregography pattern
 Drawback --CIRCULAR OR CYCLE DEPDENCY CAN MAKRS
-- REQSTES -> [EVENT]-SERVCEI1 -> SERVCIE2-> SERVCI3

2. ORACHESTRAION :
-> 

--InterView Question on this
Person a --NEED TO DO PAYMENT TO Person B

CQRS : COMMAND(CUD) QUERY(sELECT) REQUEST SEGREGATION

--CUD(create,update,delete) will performed in seperate DB BUT  READ OPEARTEION , THERE WILL BE COMMON VIEW OR DATABASE OR HISTORY WHERE ALL TABLES REQUIRED DATA EXSISTS THERE.
--THRIUGHT EVENT WE IMPLEMENT THIS. or through db trigger or proecuedure

---class 5

1 single server
2 application an db server seperation
3 load balancer +multiple app server
4 databse replication
5 cache
6 CDN
7 DATA CENTER
8 MNESSAGING QUEUE
9 

*DB
--Master DB VS SLAVE DB
--CACHE

TTL : TIME TO LIVE
CDN DOES CACHING BUT ALL THOSE WHO DOES CACHING  ARE NOT CDN LIKE REDISS CACHE
--CDB SOLVE ISSUES OF LATENCY
--CDN DOES CACHING OF STATIC  DATA LIKE HML,VIDEO, CSS FILE
- WHEN REQYEST COMEN THEN CODE NEAREST CDN NODES THAT WILL SERVER RQEUEST , IF DATA IS NOT THEN GO TO THE SERVER OR NEAR CDN NODE
--INCREASE PEROFRMANCE  AND SECUIRITY

--DATABASE SCALING 
 --TWO TYPES
1 VBERTICAL SCALING -> 
CPU CAPABILITY/RAM CAPAILITY --IN LOAD INCEACSE
--BUT THERE IS LIMIT FOR EXTEND

2.HORIZONTAL SCALING -> 
--MULTIPLE NODEE
-BY SHARDING U CAN IMPLMENT THIS.
--SHADING TWO TYPEX : VERTICAL(column wise) AND HORIZONTAL(row wise)


---consistent hashing

horzonatl shading --
virtual objects
ring
modulo
1%n
--
ankur agarwal
Millennium 

-Interview Asked
Aggegator Pattern
domain driven benefit 
discovery  pattern
request delegate--.net core use map
cutome middlware --done
cqrs pattern -done

--Inheritance symbol
Is A RelationShip => --
Has A RelationShip => --->

 Strategy Design Pattern :->

Suppose we have a base class called "Vehicle" with a method called "drive." Among the subclasses, the "PassengerVehicle" class requires the standard functionality of the "drive" method. However, the "SportsVehicle" and "OffRoadVehicle" classes need unique functionalities for the "drive" method, specific to their respective classes.
The problem arises from code duplication in the "SportsVehicle" and "OffRoadVehicle" classes due to the repetition of special functionalities limited to their respective classes. To address this issue, the Strategy Design Pattern can be employed to eliminate the redundancy and improve code readability.

childs having some code , that does not  present in base code--

*Observer Design Pattern Explanation,
The Observer Design Pattern is a behavioral design pattern that defines a one-to-many 
dependency between objects so that when one object (the subject) changes state, 
all its dependents (observers) are notified and updated automatically.
--Like notfify me feature jn website, like amazon notify me button
--it conatins two one
Obserabable- suppoese any state changes of Obserabable then it notify all observer(1 to many)
observer -
Obserabable has many observer(1 to manyh relations -has a relationship)
Observer design  pattern contains three methods
1.Add
2. Remove
3. notify

**The Decorator Design Pattern 
-> allows you to add new functionality to an existing object without altering its structure. 
   This is done by creating a decorator class that wraps the original class.
-> Real time use case :
 1.pizza shop-> like base pizza and after this mutiple top like, veggie extra, extra chigg(decorate)
  base pizaa+extra cheese+mushroom
 2. cofee
 --base coffe(expressoo) + (cream-Decorator)
 3.car -> base car + extra feature(seat cover  + ac)\

  why we need decorator pattern:
 -- class explosion -> this reduce class explosion
 -- reduce multiple class  to less class
 -- it is has-A and ISA-A Relation ship-both


----M
https://dotnetcorecentral.com/blog/chain-of-responsibility-pattern/
Bharat Ahuja
1. All Behavioral Design pattern in 1 shot: All
https://lnkd.in/gfwN7hTC

2. All Structural Design Patterns in 1 shot:
https://lnkd.in/dudjBtse

3. All Creational Design Patterns in 1 shot:
https://lnkd.in/dBbA7Htc

4. SOLID Principles with examples, by seeing which even interviewer will get amazed: 
https://lnkd.in/dhv98APT

---Microservices
https://github.com/johnph?tab=repositories
https://github.com/johnph/simple-transaction-part2/tree/master/src/Services





